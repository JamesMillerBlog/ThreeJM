(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _threejm = require('./modules/threeJM/threejm');

var _settings = require('./modules/3Dassets/settings/settings');

/* 

Functional to dos:

	2. Update Github
		- Documentation

	Nice to haves:
	1. First person controls for mobile 
	2. Create animation function
	3. WEBVR + Polyfill
		- test vr on windows desktop
	4. Find flying camera object to replace current
		- Set flyControls to true within this file
		- Fix Reticulum
	5. Add CMS functionality
	6. Add in physics "compounds" for complex physics

*/

// set up a three js scene in VR Mode
//Original tutorial: http://bit.ly/2mDJbdu

var ThreeJm = new _threejm.threejm(_settings.settings);

// set background
ThreeJm.setBackground(_settings.settings.assets.environment.backgroundImage);

// create floor
ThreeJm.createFloor(_settings.settings.assets.environment.floor);

// create light source
ThreeJm.createLight(_settings.settings.assets.lighting.mainLight);

// create shapes
ThreeJm.createShape('lookable', _settings.settings.assets.objects.poly.lookable);
ThreeJm.createShape('photoSphere', _settings.settings.assets.objects.photoSphere.photoSphereOne);

// ThreeJm.createShape('space', assets.objects.space);
ThreeJm.createShape('videoSphere', _settings.settings.assets.objects.videoSphere.videoSphereOne);
// ThreeJm.createShape('sailingScrollSphere', assets.objects.sailingScrollSphere);

// load model
ThreeJm.loadModel('testModels', _settings.settings.assets.models.example);

// animate shapes
// ThreeJm.animateShape('photoSphere', assets.objects.photoSphere);

// ThreeJm.flyControls = false;

},{"./modules/3Dassets/settings/settings":10,"./modules/threeJM/threejm":21}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.assets = undefined;

var _dObjects = require('./objects/3dObjects');

var _dEnvironment = require('./environment/3dEnvironment');

var _dLightingEffects = require('./lighting/3dLightingEffects');

var _dModels = require('./models/3dModels');

var assets = exports.assets = {
	objects: _dObjects.objects,
	environment: _dEnvironment.environment,
	lighting: _dLightingEffects.lighting,
	models: _dModels.models
};

},{"./environment/3dEnvironment":3,"./lighting/3dLightingEffects":4,"./models/3dModels":5,"./objects/3dObjects":6}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var environment = exports.environment = {
	floor: {
		texture: {
			textureImage: "./assets/scenery/wood.jpg",
			textureWrap: {
				wrapS: "RepeatWrapping",
				wrapT: "RepeatWrapping",
				textureRepeat: [50, 50]
			},
			textureAnisotrophy: true
		},
		material: {
			type: "MeshPhongMaterial",
			color: "0xffffff",
			specular: "0xffffff",
			shininess: 5,
			shading: "FlatShading"
		},
		geometry: {
			type: "PlaneGeometry",
			size: [50, 50]
		},
		mesh: {
			rotation: {
				x: -Math.PI / 2,
				y: 0,
				z: 0
			},
			position: {
				x: 0,
				y: 0,
				z: 0
			},
			visible: true,
			standable: true,
			reticle: false
		},
		physics: {
			type: "Plane",
			mass: 0,
			quaternion: {
				x: 1,
				y: 0,
				z: 0
			},
			fall: {
				height: 10,
				restart: true
			},
			wall: true
		}
	},
	backgroundImage: {
		type: "CubeTextureLoader",
		path: './assets/photo/',
		image: {
			left: 'px.jpg',
			right: 'nx.jpg',
			top: 'py.jpg',
			bottom: 'ny.jpg',
			front: 'pz.jpg',
			back: 'nz.jpg'
		}
	}
};

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var lighting = exports.lighting = {
	mainLight: {
		type: "PointLight",
		pos: {
			x: 0,
			y: 15,
			z: 0
		},
		option: [2, 100]
	}
};

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var models = exports.models = {
	example: {
		material: {
			color: 0x55B663,
			specular: "0xffffff",
			shininess: 5
		},
		geometry: {
			type: 'JSON',
			src: './assets/models/treehouse_logo.js',
			size: [3, 1, 3]
		},
		mesh: {
			name: "example",
			rotation: {
				x: 0,
				y: 0,
				z: 0
			},
			position: {
				x: 0,
				y: 0,
				z: -10
			},
			scale: {
				x: 1,
				y: 1,
				z: 1
			},
			reticle: {
				display: true,
				scrollColor: 0xff0000,
				gazed: function gazed(name) {
					console.log("Gazed at " + name + "!");
				}
			}
		},
		physics: {
			type: "Box",
			mass: 5
			// ,
			// sound: {
			// 	src: './assets/sounds/reborn.mp3'
			// }
		} }
};

},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.objects = undefined;

var _videoSphere = require('./content/videoSphere');

var videoSphere = _interopRequireWildcard(_videoSphere);

var _photoSphere = require('./content/photoSphere');

var photoSphere = _interopRequireWildcard(_photoSphere);

var _poly = require('./content/poly');

var poly = _interopRequireWildcard(_poly);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var objects = exports.objects = {
	videoSphere: videoSphere,
	photoSphere: photoSphere,
	poly: poly
};

},{"./content/photoSphere":7,"./content/poly":8,"./content/videoSphere":9}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var space = exports.space = {
	texture: {
		textureImage: "./assets/photo/space.png",
		sphere: "photo"
	},
	material: {
		type: "MeshBasicMaterial",
		depthTest: true,
		depthWrite: true
	},
	geometry: {
		type: "SphereGeometry",
		size: [5000, 32, 32]
	},
	animate: {
		position: {
			direction: '+=',
			x: .01
		}
	},
	mesh: {
		rotation: {
			x: 0,
			y: 0,
			z: 0
		},
		position: {
			x: 60,
			y: 15,
			z: -30
		},
		scale: {
			x: -1,
			y: 1,
			z: 1
		},
		reticle: {
			display: false
		},
		visible: true
	}
};

var photoSphereOne = exports.photoSphereOne = {
	texture: {
		textureImage: "./assets/photo/bergsjostolen.jpg",
		sphere: "photo"
	},
	material: {
		type: "MeshBasicMaterial",
		depthTest: false,
		depthWrite: false
	},
	geometry: {
		type: "SphereGeometry",
		size: [30, 32, 32]
	},
	animate: {
		position: {
			direction: '+=',
			x: .01
		}
	},
	mesh: {
		rotation: {
			x: 0,
			y: 0,
			z: 0
		},
		position: {
			x: 60,
			y: 15,
			z: -30
		},
		scale: {
			x: -1,
			y: 1,
			z: 1
		},
		reticle: {
			display: false
		},
		visible: true
	}
};

var sailingScrollSphere = exports.sailingScrollSphere = {
	material: {
		type: "MeshBasicMaterial",
		color: 0xffffff,
		opacity: .5,
		transparent: true,
		depthTest: false,
		depthWrite: false
	},
	geometry: {
		type: "SphereGeometry",
		size: [29, 32, 32]
		// size: [1, 32, 32]
	},
	mesh: {
		rotation: {
			x: 0,
			y: 0,
			z: 0
		},
		position: {
			// x: 0,
			// y: 1,
			// z: 0
			x: -40,
			y: 10,
			z: -60
		},
		scale: {
			x: 1,
			y: 1,
			z: 1
		},
		visible: true,
		reticle: {
			display: true,
			scrollColor: 0xff0000,

			gazeClick: function gazeClick(material, self) {

				// material.opacity = 0;

				var targetPosition = objects.sailingScrollSphere.mesh.position;
				var objectToMove = self.camera.position;
				var duration = 1000;
				objects.sailingScrollSphere.mesh.tween.animate(objectToMove, targetPosition, duration);

				self.renderer.domElement.addEventListener('click', exitSphere, true);

				function exitSphere() {
					objects.sailingScrollSphere.mesh.tween.animate(objectToMove, { x: 0, y: 0, z: 0 }, duration);
					self.renderer.domElement.removeEventListener('click', exitSphere, false);
				}
			},
			onGazeOver: function onGazeOver(material, self) {
				console.log("Gaze Over " + material + "!");
				material.opacity = 0;
			},
			onGazeOut: function onGazeOut(material, self) {
				console.log("Gaze Out");
				material.opacity = .5;
			},
			gazeLong: function gazeLong(material, self) {}
		},
		tween: {
			animate: function animate(objectToMove, targetPosition, duration) {
				var tween = new TWEEN.Tween(objectToMove).to(targetPosition, duration).start();
			}
			// renderOrder: 2,
		} }
};

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var lookable = exports.lookable = {
	texture: null,
	material: {
		color: 0xffffff,
		type: "MeshLambertMaterial",
		transparent: true
	},
	geometry: {
		type: "BoxGeometry",
		size: [3, .5, 3]
	},
	mesh: {
		name: 'lookable',
		rotation: {
			x: 0,
			y: 80,
			z: 0
		},
		position: {
			x: 5,
			y: 0,
			z: -5
		},
		visible: true,
		reticle: {
			display: true,
			scrollColor: 0xff0000,
			gazeClick: function gazeClick(material) {
				console.log("Gaze Clicked " + material + "!");
				material.opacity = 0;
			},
			onGazeOver: function onGazeOver(material) {
				console.log("Gaze Over " + material + "!");
				material.opacity = 0.5;
			},
			onGazeOut: function onGazeOut(material) {
				console.log("Gaze Out");
				material.opacity = 1;
			}
		}
	},
	physics: {
		type: "Box",
		mass: 5
		// ,
		// sound: {
		// 	src: './assets/sounds/reborn.mp3'
		// }
	} };

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var videoSphereOne = exports.videoSphereOne = {
	texture: {
		textureImage: "./assets/video/pano.mp4",
		sphere: "video"
	},
	material: {
		type: "MeshBasicMaterial",
		transparent: true,
		opacity: .8,
		depthTest: false,
		depthWrite: false
	},
	geometry: {
		type: "SphereGeometry",
		// size: [5, 32, 32]
		size: [29, 32, 32]
	},
	mesh: {
		rotation: {
			x: 0,
			y: 0,
			z: 0
		},
		position: {
			x: -50,
			y: 1,
			// z: -100
			z: -80
		},
		scale: {
			x: -1,
			y: 1,
			z: 1
		},
		clicked: false,
		reticle: {
			display: true,
			scrollColor: 0xff0000,
			gazeClick: function gazeClick(material, self) {
				videoSphereOne.mesh.clicked = true;
				material.opacity = 1;
				console.log("Video gaze click");
				var targetPosition = videoSphereOne.mesh.position;
				var objectToMove = self.camera.position;
				var duration = 1000;

				videoSphereOne.mesh.tween.animate(objectToMove, targetPosition, duration);

				setTimeout(function () {
					self.renderer.domElement.addEventListener('click', exitSphere, true);
				}, duration);

				function exitSphere() {
					if (videoSphereOne.mesh.clicked) {
						videoSphereOne.mesh.clicked = false;
						material.opacity = .7;
						videoSphereOne.mesh.tween.animate(objectToMove, { x: 0, y: 0, z: 0 }, duration);
						self.renderer.domElement.removeEventListener('click', exitSphere, false);
					}
				}
			},
			onGazeOver: function onGazeOver(material, self) {
				console.log("Video gaze Over " + material + "!");
				material.opacity = 1;
			},
			onGazeOut: function onGazeOut(material, self) {
				console.log("Video gaze Out");
				if (!videoSphereOne.mesh.clicked) material.opacity = .7;
			},
			gazeLong: function gazeLong(material, self) {
				console.log("Video gaze long");
			}
		},
		tween: {
			animate: function animate(objectToMove, targetPosition, duration) {
				var tween = new TWEEN.Tween(objectToMove).to(targetPosition, duration).start();
			}
		},
		visible: true
		// renderOrder: 1
		// functions: {
		// 	tap: function(material, self) {

		// 		self.renderer.domElement.addEventListener('click', enterSphere, true);

		// 		function enterSphere() {
		// 			console.log("trigger");
		// 			// objects.sailingScrollSphere.mesh.tween.animate(objectToMove, {x:0,y:0,z:0}, duration);					    
		// 			self.renderer.domElement.removeEventListener('click', enterSphere, false);
		// 		}
		// 		// console tap
		// 		// fix location of object once detected
		// 		// check if detection is true
		// 		// swap camera to device orientation
		// 		// animate camera into object
		// 		// look around 360
		// 		// click again animate to original position
		// 		// swap camera back to original
		// 	}
		// }
	}
};

},{}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.settings = undefined;

var _dAssets = require('../assets/3dAssets');

var settings = exports.settings = {
	mode: 'vr'
	// 'ar'
	// 'model'
	// 'threesixty'

	, controls: {
		flightmode: true, // gravity activated?
		movement: true // ability to freely move?
	},
	UI: {
		instructions: true
	},
	AR: {
		arMarker: false,
		video: false, //use live webcam feed in vr setup,
		arPattern: '/assets/ar/marker16.pat'
	},
	assets: _dAssets.assets
};

},{"../assets/3dAssets":2}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
				value: true
});
exports.resize = resize;
/*** RESIZE 3D OBJECTS BASED ON BROWSER SIZE EVERY FRAME ***/
function resize() {
				if (!self.arMarker) {
								self.camera.aspect = window.innerWidth / window.innerHeight;
								// updates the camera object with the new aspect ratios
								self.camera.updateProjectionMatrix();
								self.deviceRendered.setSize(window.innerWidth, window.innerHeight);
				}
}

window.onresize = function (event) {
				resize();
};

},{}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.THREESIXTYcameracontrol = THREESIXTYcameracontrol;
exports.MODELcameracontrol = MODELcameracontrol;
exports.VRcameracontrol = VRcameracontrol;
exports.ARcameracontrol = ARcameracontrol;
function THREESIXTYcameracontrol() {
	self.controls = new PointerLockControls(self.camera, self.sphereBody);
	clickToStart();
	//render full screen experience (desktop)
	self.deviceRendered = self.renderer;
	//once controls have been set, add them to the scene
	self.scene.add(self.controls.getObject());
}

/*** CONTROLS FOR MOVING THE CAMERA IN MODEL MODE ***/
function MODELcameracontrol() {
	var blocker = document.getElementById('blocker');
	blocker.style.display = 'none';
	self.camera.position.z = 50;
	self.camera.position.y = 30;
	self.deviceRendered = self.renderer;
	self.controls = new THREE.OrbitControls(self.camera, self.deviceRendered.domElement);
	// self.controls.addEventListener( 'change', render ); // remove when using animation loop

	// enable animation loop when using damping or autorotation
	//controls.enableDamping = true;
	//controls.dampingFactor = 0.25;
	self.controls.enableZoom = false;
}

/*** CONTROLS FOR MOVING THE CAMERA IN VR MODE ***/
function VRcameracontrol() {
	// Pass camera and DOM element into the OrbitControls so that event listeners can be attached
	var blocker = document.getElementById('blocker');
	var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
	clickToStart();
	if (self.flyControls && !self.ismobile) {
		self.controls = new THREE.FlyControls(self.camera);
		self.controls.movementSpeed = 25;
		self.controls.rollSpeed = Math.PI / 6;
		self.controls.autoForward = false;
		self.controls.dragToLook = false;

		self.deviceRendered = self.renderer;

		self.controls.mouseMovement = false;
		self.controls.enabled = false;
		self.controlsEnabled = false;
		// blocker.style.display = 'none';
	} else if (havePointerLock && !self.flyControls) {
		// if ( havePointerLock ) {
		self.controls = new PointerLockControls(self.camera, self.sphereBody);
		// self.controls.mouseMovement = true;
		// self.controls = new PointerLockControls( self.camera, camPhysics );
		// clickToStart();
		//render full screen experience (desktop)
		self.deviceRendered = self.renderer;
		//once controls have been set, add them to the scene
		self.scene.add(self.controls.getObject());
	} else if (!havePointerLock && !self.ismobile) {

		instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
	} else if (self.ismobile) {
		var doOnOrientationChange = function doOnOrientationChange() {
			self.deviceRendered.setSize(window.innerWidth, window.innerHeight);
		};

		var cardBoardView = function cardBoardView() {
			// landscape vrMode
			// if(window.orientation == -90 || window.orientation == 90) self.deviceRendered = self.effect;  
			// else self.deviceRendered = self.renderer; // portrait full screen mode
			self.deviceRendered = self.renderer;
			// Set the camera controller to the orientation of the phone.
			self.controls = new THREE.DeviceOrientationControls(self.camera, true);
			self.controls.mouseMovement = false;
			// Use DeviceOrientationControls object to set up new camera controls.
			self.controls.connect();
			// Finish updating the camera controls.
			self.camera.position.set(0, self.cameraHeight * 30, 30);
			self.controls.update();
			self.controls.movementSpeed = self.cameraMovement;
			self.deviceRendered.setSize(window.innerWidth, window.innerHeight);
		};

		/*** FULL SCREEN WHEN ON VR HEADSET ***/


		var fullscreen = function fullscreen() {
			//split screen for vr headset on mobile devices
			self.video.play();
			if (self.container.requestFullscreen) {
				self.container.requestFullscreen();
			} else if (self.container.msRequestFullscreen) {
				self.container.msRequestFullscreen();
			} else if (self.container.mozRequestFullScreen) {
				self.container.mozRequestFullScreen();
			} else if (self.container.webkitRequestFullscreen) {
				self.container.webkitRequestFullscreen();
			}
			window.removeEventListener('click', fullscreen, false); // hide address bar
		};

		// blocker.style.display = 'none';
		// self.controls = new THREE.FirstPersonControls(self.camera);
		// self.controls.movementSpeed = 1000;

		// onOrientationChange();
		window.addEventListener('touchend', fullscreen); // hide address bar
		window.addEventListener('orientationchange', doOnOrientationChange);
		// window.addEventListener('orientationchange', cardBoardView);
		cardBoardView();
	}
	// Device orientation returns alpha, beta, gamma
	function setOrientationControls(e) {
		// If alpha values aren't coming through, stop function
		if (!e.alpha || e.alpha == null || e.alpha === false) return;
		// Once the camera controller is set up, remove the event listener
		window.removeEventListener('deviceorientation', setOrientationControls, true);
	}
	// Detect motion of phone in vr device.
	window.addEventListener('deviceorientation', setOrientationControls, true);
}

/*** CONTROLS FOR MOVING THE CAMERA IN VR MODE ***/
function ARcameracontrol() {
	// Pass camera and DOM element into the OrbitControls so that event listeners can be attached
	var blocker = document.getElementById('blocker');
	var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
	clickToStart();
	if (self.flyControls) {
		self.controls = new THREE.FlyControls(self.camera);
		self.controls.movementSpeed = 25;
		self.controls.rollSpeed = Math.PI / 6;
		self.controls.autoForward = false;
		self.controls.dragToLook = false;

		self.deviceRendered = self.renderer;

		self.controls.mouseMovement = false;
		self.controls.enabled = false;
		self.controlsEnabled = false;
		// blocker.style.display = 'none';
	} else if (havePointerLock && !self.flyControls && !self.arMarker) {
		// if ( havePointerLock ) {
		self.controls = new PointerLockControls(self.camera, self.sphereBody);
		// self.controls.mouseMovement = true;
		// self.controls = new PointerLockControls( self.camera, camPhysics );
		// clickToStart();
		//render full screen experience (desktop)
		self.deviceRendered = self.renderer;
		//once controls have been set, add them to the scene
		self.scene.add(self.controls.getObject());
	} else if (!havePointerLock && !self.ismobile) {

		instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
	} else if (self.ismobile && !self.arMarker) {
		var doOnOrientationChange = function doOnOrientationChange() {
			self.deviceRendered.setSize(window.innerWidth, window.innerHeight);
		};

		var cardBoardView = function cardBoardView() {
			// landscape vrMode
			// if(window.orientation == -90 || window.orientation == 90) self.deviceRendered = self.effect;  
			// else self.deviceRendered = self.renderer; // portrait full screen mode
			self.deviceRendered = self.renderer;
			// Set the camera controller to the orientation of the phone.
			self.controls = new THREE.DeviceOrientationControls(self.camera, true);
			self.controls.mouseMovement = false;
			// Use DeviceOrientationControls object to set up new camera controls.
			self.controls.connect();
			// Finish updating the camera controls.
			self.camera.position.set(0, self.cameraHeight * 30, 30);
			self.controls.update();
			self.deviceRendered.setSize(window.innerWidth, window.innerHeight);
		};

		/*** FULL SCREEN WHEN ON VR HEADSET ***/


		var fullscreen = function fullscreen() {
			//split screen for vr headset on mobile devices
			self.video.play();
			if (self.container.requestFullscreen) {
				self.container.requestFullscreen();
			} else if (self.container.msRequestFullscreen) {
				self.container.msRequestFullscreen();
			} else if (self.container.mozRequestFullScreen) {
				self.container.mozRequestFullScreen();
			} else if (self.container.webkitRequestFullscreen) {
				self.container.webkitRequestFullscreen();
			}
			window.removeEventListener('click', fullscreen, false); // hide address bar
		};

		// blocker.style.display = 'none';
		// self.controls = new THREE.FirstPersonControls(self.camera);
		// self.controls.movementSpeed = 1000;

		// onOrientationChange();
		window.addEventListener('touchend', fullscreen); // hide address bar
		window.addEventListener('orientationchange', doOnOrientationChange);
		// window.addEventListener('orientationchange', cardBoardView);
		cardBoardView();
	} else if (self.arMarker) {
		////////////////////////////////////////////////////////////////////////////////
		//          Create a ArMarkerControls
		////////////////////////////////////////////////////////////////////////////////
		// init controls for camera
		self.markerControls = new THREEx.ArMarkerControls(self.arToolkitContext, self.camera, {
			type: 'pattern',
			// patternUrl : './assets/ar/patt.hiro',
			patternUrl: self.arPattern,
			// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
			// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
			changeMatrixMode: 'cameraTransformMatrix'
		});
		// as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
		self.scene.visible = false;
		self.deviceRendered = self.renderer;
	}
	// Device orientation returns alpha, beta, gamma
	function setOrientationControls(e) {
		// If alpha values aren't coming through, stop function
		if (!e.alpha || e.alpha == null || e.alpha === false) return;
		// Once the camera controller is set up, remove the event listener
		window.removeEventListener('deviceorientation', setOrientationControls, true);
	}
	// Detect motion of phone in vr device.
	window.addEventListener('deviceorientation', setOrientationControls, true);
}

function clickToStart() {
	var instructions = document.getElementById('instructions');
	var element = document.body;

	document.onkeypress = function (e) {
		if (!self.arMarker) {
			e = e || window.event;
			if (isInt(e.key)) flyLockChange();
			// use e.keyCode
		} else {
			blocker.style.display = '';
		}
	};

	var pointerlockchange = function pointerlockchange(event) {
		if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
			console.log("controls enabled");
			self.controlsEnabled = true;
			self.controls.enabled = true;
			blocker.style.display = 'none';
			instructions.style.display = 'none';
		} else {
			console.log("controls disabled");
			self.controls.enabled = false;
			self.controlsEnabled = false;
			blocker.style.display = '-webkit-box';
			blocker.style.display = '-moz-box';
			blocker.style.display = '';
			instructions.style.display = '';
		}
	};

	function flyLockChange() {
		if (!self.controls.mouseMovement) blocker.style.display = 'none';else blocker.style.display = '';
		self.controlsEnabled = true;
		self.controls.mouseMovement = !self.controls.mouseMovement;
	}

	var pointerlockerror = function pointerlockerror(event) {
		instructions.style.display = '';
	};
	// Hook pointer lock state change events
	document.addEventListener('pointerlockchange', pointerlockchange, false);
	document.addEventListener('mozpointerlockchange', pointerlockchange, false);
	document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

	document.addEventListener('pointerlockerror', pointerlockerror, false);
	document.addEventListener('mozpointerlockerror', pointerlockerror, false);
	document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

	if (!self.instructions) {
		blocker.style.display = 'none';
		instructions.style.display = 'none';
	} else {
		instructions.addEventListener('click', function (event) {
			// Ask the browser to lock the pointer
			if (self.flyControls) {
				flyLockChange();
			} else if (self.arMarker) {
				blocker.style.display = 'none';
			} else {
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
				element.requestPointerLock();
			}
		}, false);
	}
}

function isInt(value) {

	var er = /^-?[0-9]+$/;

	return er.test(value);
}

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.worldPhysics = worldPhysics;
exports.setCamPhysics = setCamPhysics;
exports.addPhysics = addPhysics;
exports.addPhysicsFloor = addPhysicsFloor;
function worldPhysics() {

    self.world = new CANNON.World();
    self.world.quatNormalizeSkip = 0;
    self.world.quatNormalizeFast = false;

    var solver = new CANNON.GSSolver();

    self.world.defaultContactMaterial.contactEquationStiffness = 1e9;
    self.world.defaultContactMaterial.contactEquationRelaxation = 4; // bouncyness

    solver.iterations = 7;
    solver.tolerance = 0.1;
    var split = true;
    if (split) {
        self.world.solver = new CANNON.SplitSolver(solver);
    } else {
        self.world.solver = solver;
    }

    self.world.gravity.set(0, -20, 0);
    self.world.broadphase = new CANNON.NaiveBroadphase();
    self.world.broadphase.useBoundingBoxes = true;

    // Create a slippery material (friction coefficient = 0.0)
    self.physicsmaterial = new CANNON.Material("slipperyMaterial");
    var physicsContactMaterial = new CANNON.ContactMaterial(self.physicsmaterial, self.physicsmaterial, 0.0, // friction coefficient
    0.3 // restitution
    );
    // We must add the contact materials to the self.world
    self.world.addContactMaterial(physicsContactMaterial);
}

function setCamPhysics() {
    // Create gravity for camera
    var mass = 5;
    if (self.arMarker) mass = 0;
    var radius = 1.3;
    var sphereShape = new CANNON.Sphere(radius);
    self.sphereBody = new CANNON.Body({ mass: mass, material: self.physicsmaterial });
    self.sphereBody.addShape(sphereShape);
    self.sphereBody.position.set(0, 5, 0);
    self.sphereBody.linearDamping = 0.9; // sliding
    self.world.addBody(self.sphereBody);
}

function addPhysics(createdShape) {
    // Physics options
    var physicsTypes = [CANNON.Plane, CANNON.Box];
    var physicsStrings = ["Plane", "Box"];

    //for each type of material listed above
    for (var x = 0; x < physicsTypes.length; x++) {
        //check if the passed material matches one of them
        if (createdShape.physics.type == physicsStrings[x]) {
            // if physics type is a plane
            if (createdShape.physics.type == "Plane") var physicsShape = new physicsTypes[x]();
            // otherwise create the correct physics with the associated type
            else {
                    // Object sizes
                    var halfExtents = new CANNON.Vec3(createdShape.geometry.size[0] / 2, createdShape.geometry.size[1] / 2, createdShape.geometry.size[2] / 2);
                    var physicsShape = new physicsTypes[x](halfExtents);
                }
            // Create the body that has mass to be touched
            var physicsBody = new CANNON.Body({ mass: createdShape.physics.mass });
            // Add the shape to the mass
            physicsBody.addShape(physicsShape);
            // set other physics options
            physicsBody.position.set(createdShape.mesh.position.x, createdShape.mesh.position.y, createdShape.mesh.position.z);
            if (createdShape.physics.quaternion) physicsBody.quaternion.setFromAxisAngle(new CANNON.Vec3(createdShape.physics.quaternion.x, createdShape.physics.quaternion.y, createdShape.physics.quaternion.z), -Math.PI / 2);else if (createdShape.mesh.rotation) physicsBody.quaternion.setFromAxisAngle(new CANNON.Vec3(createdShape.mesh.rotation.x, createdShape.mesh.rotation.y, createdShape.mesh.rotation.z), -Math.PI / 2);

            // add physics to the scene
            self.world.addBody(physicsBody);

            // add physics to global array for animation
            self.physicsObjects.push(physicsBody);
        }
    }
}

function addPhysicsFloor(createdFloor) {
    // declare physics shape type
    var floorShape = new CANNON.Plane();
    // declare mass of physis body
    var floorBody = new CANNON.Body({ mass: createdFloor.physics.mass });
    floorBody.addShape(floorShape);

    // set physics options
    if (createdFloor.physics.quaternion) floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(createdFloor.physics.quaternion.x, createdFloor.physics.quaternion.y, createdFloor.physics.quaternion.z), -Math.PI / 2);
    if (createdFloor.physics.fall.height > 0) {
        createFloorEdge(createdFloor, floorBody);
        if (createdFloor.physics.fall.restart) activateFloorRestart(createdFloor, floorBody);
    }
    if (createdFloor.physics.wall) createFloorWalls(createdFloor, floorBody);
    self.world.addBody(floorBody);
}

function createFloorEdge(createdFloor, floorBody) {
    floorBody.position.set(0, -createdFloor.physics.fall.height, 0);
    var halfExtents = new CANNON.Vec3(createdFloor.geometry.size[0] / 2, createdFloor.physics.fall.height / 2, createdFloor.geometry.size[1] / 2);
    var realFloorShape = new CANNON.Box(halfExtents);
    var realFloorBody = new CANNON.Body({ mass: createdFloor.physics.mass });
    realFloorBody.addShape(realFloorShape);
    realFloorBody.position.set(0, -createdFloor.physics.fall.height / 2, 0);
    self.world.addBody(realFloorBody);
}

function createFloorWalls(createdFloor, floorBody) {
    for (var x = 0; x < 4; x++) {
        var halfExtents = new CANNON.Vec3(createdFloor.geometry.size[0] / 2, createdFloor.physics.fall.height, createdFloor.geometry.size[1] / 2);
        var wallShape = new CANNON.Box(halfExtents);
        var wallBody = new CANNON.Body({ mass: createdFloor.physics.mass });
        wallBody.addShape(wallShape);
        // create right wall
        if (x == 0) wallBody.position.set(createdFloor.geometry.size[0], 0, 0);
        // create left wall
        else if (x == 1) wallBody.position.set(-createdFloor.geometry.size[0], 0, 0);
            // create front wall
            else if (x == 2) wallBody.position.set(0, 0, createdFloor.geometry.size[1]);
                // create back wall
                else if (x == 3) wallBody.position.set(0, 0, -createdFloor.geometry.size[1]);
        // push each wall into the scene
        self.world.addBody(wallBody);
    }
}

function activateFloorRestart(createdFloor, floorBody) {
    self.fallHeight = -createdFloor.physics.fall.height / 2;
}

},{}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.update = update;
/*** RE-RENDER ALL CONTENT EVERY FRAME ***/
function update(dt, mode, resize, nowMsec) {
    // // update the picking ray with the camera and mouse position
    if (mode == 'vr' || mode == 'threesixty') {
        Reticulum.update();
        // // check if fall height has been set (only happens if fall restart has been set to true)
        if (self.fallHeight < 0) {
            if (self.sphereBody.position.y <= self.fallHeight) {
                self.sphereBody.position.y = 5;
                self.sphereBody.position.x = 0;
                self.sphereBody.position.z = 0;
            }
        }
    }
    if (!self.arMarker) if (self.controls.enabled) self.world.step(dt);
    // // Update box positions
    for (var i = 0; i < self.physicsObjects.length; i++) {
        self.physicsMeshes[i].position.copy(self.physicsObjects[i].position);
        self.physicsMeshes[i].quaternion.copy(self.physicsObjects[i].quaternion);
    }
    TWEEN.update();

    // measure time
    self.lastTimeMsec = self.lastTimeMsec || nowMsec - 1000 / 60;
    var deltaMsec = Math.min(200, nowMsec - self.lastTimeMsec);
    self.lastTimeMsec = nowMsec;

    self.onRenderFcts.forEach(function (onRenderFct) {
        onRenderFct(deltaMsec / 1000, nowMsec / 1000);
    });
    // animation code that is commented out
    // // if(self.animatingObjects.length > 0) animateObjects(self.animatingObjects);

    // // if(self.flyControls && !self.controls.update) VRcameracontrol();
    // // if(self.flyControls) VRcameracontrol();
    // if(self.ismobile || self.flyControls) {
    //     // self.controls.update(dt);
    //     // self.renderer.clear();
    // }

    window.onresize = function (event) {
        resize();
    };

    if (!self.arMarker) {
        if (self.flyControls) {
            self.controls.update(dt);
            self.renderer.clear();
        } else {
            self.controls.update(Date.now() - self.time);
            self.time = Date.now();
        }
    }
    self.deviceRendered.render(self.scene, self.camera);

    self.deviceRendered.setSize(window.innerWidth, window.innerHeight);

    // if(markerControls.object3d.visible) vrRedirect(); // remove this for vr code


    // $( "#data" ).html(self.controls.object.position.y);
}

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.setup = setup;


/*** STARTING THE THREE.JS SCENE ***/
function setup(mode) {
	//creates an object that allows where 3D elements can be rendered + placed
	self.scene = new THREE.Scene();
	// PerspectiveCamera(FOV, aspect, near, far).

	// FOV = the vertical field of view for the camera.
	// Aspect =  the aspect ratio for the camera. Normally width/ height or can also be set to 1.
	// Near + Far = only elements between the near and far values from our camera are rendered.
	if (mode != "ar") {
		self.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
		self.camera.position.set(0, self.cameraHeight, 0);
	} else self.camera = new THREE.Camera();
	// Camera.position.set(x,y,z)
	self.scene.add(self.camera);

	if (mode == 'vr' || mode == "ar" || mode == 'threesixty') {
		// --- Reticulum ---
		// initiate Reticulum so it loads up 
		Reticulum.init(self.camera, {
			proximity: false,
			clickevents: true,
			near: null, //near factor of the raycaster (shouldn't be negative and should be smaller than the far property)
			far: null, //far factor of the raycaster (shouldn't be negative and should be larger than the near property)
			reticle: {
				visible: true,
				restPoint: 10, //Defines the reticle's resting point when no object has been targeted
				color: 0xcc00cc,
				innerRadius: 0.0001,
				outerRadius: 0.003,
				hover: {
					color: 0x00cccc,
					innerRadius: 0.02,
					outerRadius: 0.024,
					speed: 5,
					vibrate: 50 //Set to 0 or [] to disable
				}
			},
			fuse: {
				visible: true,
				duration: 2.5,
				color: 0x00fff6,
				innerRadius: 0.045,
				outerRadius: 0.06,
				vibrate: 0, //Set to 0 or [] to disable
				clickCancelFuse: true //If users clicks on targeted object fuse is canceled
			}
		});
	}

	// Create an element to render the scene with 3d objects in
	// Two renderes exist: WebGLRenderer and CanvasRenderer
	// WebGL is faster but more complicated?
	// Canvas is slower but easier to work with?
	if (mode != "ar") {
		self.renderer = new THREE.WebGLRenderer({
			antialias: self.videoBackground,
			alpha: self.videoBackground
		});
		self.renderer.setSize(window.innerWidth, window.innerHeight);
		self.renderer.sortObjects = true;
		// Declare the webglrenderer as a dom element (canvas)
		var element = self.renderer.domElement;
		// Create a webglviewer element
		var container = document.getElementById("webglviewer");
		// Pass the renderer into it.
		container.appendChild(element);
		if (self.videoBackground) {
			var onResize = function onResize() {
				self.arToolkitSource.onResize();
				// self.arToolkitSource.copySizeTo(self.renderer.domElement);
				// if( self.arToolkitContext.arController !== null ){
				//     self.arToolkitSource.copySizeTo(self.arToolkitContext.arController.canvas);
				// }
			};

			self.arToolkitSource = new THREEx.ArToolkitSource({
				// to read from the webcam
				sourceType: 'webcam'
				// // to read from an image
				// sourceType : 'image',
				// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',
				// to read from a video
				// sourceType : 'video',
				// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
			});
			self.arToolkitSource.init(function onReady() {
				onResize();
			});
			// handle resize
			window.addEventListener('resize', function () {
				onResize();
			});
		}
	} else {
		var _onResize = function _onResize() {
			self.arToolkitSource.onResize();
			self.arToolkitSource.copySizeTo(self.renderer.domElement);
			if (self.arToolkitContext.arController !== null) {
				self.arToolkitSource.copySizeTo(self.arToolkitContext.arController.canvas);
			}
		};

		///////////////////////////////////////////////////////////////////////////////
		//          initialize arToolkitContext
		////////////////////////////////////////////////////////////////////////////////
		// create atToolkitContext


		var lastKnownPos = void 0,
		    lastSeenPos = false;

		self.renderer = new THREE.WebGLRenderer({
			antialias: true,
			alpha: true
		});
		self.renderer.setClearColor(new THREE.Color('lightgrey'), 0);
		// self.renderer.setSize( 640, 480 );
		self.renderer.setSize(window.innerWidth, window.innerHeight);
		var element = self.renderer.domElement;
		// Create a webglviewer element
		var container = document.getElementById("webglviewer");
		// Pass the renderer into it.
		container.appendChild(element);

		// element.style.position = 'absolute';
		// element.style.top = '0px';
		// element.style.left = '0px';


		self.arToolkitSource = new THREEx.ArToolkitSource({
			// to read from the webcam
			sourceType: 'webcam'
			// // to read from an image
			// sourceType : 'image',
			// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',
			// to read from a video
			// sourceType : 'video',
			// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
		});
		self.arToolkitSource.init(function onReady() {
			_onResize();
		});
		// handle resize
		window.addEventListener('resize', function () {
			_onResize();
		});

		self.arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: './assets/ar/camera_para.dat',
			detectionMode: 'mono'
		});
		// initialize it
		self.arToolkitContext.init(function onCompleted() {
			// copy projection matrix to camera
			self.camera.projectionMatrix.copy(self.arToolkitContext.getProjectionMatrix());
		});
		// update artoolkit on every frame
		self.onRenderFcts.push(function () {
			if (self.arToolkitSource.ready === false) return;
			self.arToolkitContext.update(self.arToolkitSource.domElement);
			// update scene.visible if the marker is seen
			self.scene.visible = self.camera.visible;

			// detect if the orb has been shown at least once
			// display the scene from that point on
			// display the camera at those co-ords
			// when updated with new co-ords, update the position
		});
	}

	//Activate VR stereoscopic view, pass the renderer through the StereoEffect object
	self.effect = new THREE.StereoEffect(self.renderer);
	//Keep track of the time running in vr experience and the space between each render
	// self.clock = new THREE.Clock();
	self.ismobile = navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(webOS)/i);
}

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.setBackground = setBackground;
/*** 360 BACKGROUND ***/
function setBackground(self, background) {
	var backgroundTypes = [THREE.CubeTextureLoader];
	var backgroundStrings = ["CubeTextureLoader"];
	//for each type of light listed above
	for (var x = 0; x < backgroundTypes.length; x++) {
		//check if the passed light matches one of them
		if (background.type == backgroundStrings[x]) {
			//create a background with the associated type
			self.scene.background = new backgroundTypes[x]().setPath(background.path).load([background.image.left, background.image.right, background.image.top, background.image.bottom, background.image.front, background.image.back]);
		}
	}
}

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.createLight = createLight;
function createLight(self, light) {
	var lightingTypes = [THREE.PointLight];
	var lightingStrings = ["PointLight"];
	//for each type of light listed above
	for (var x = 0; x < lightingTypes.length; x++) {
		//check if the passed light matches one of them
		if (light.type == lightingStrings[x]) {
			//create a light with the associated type
			var lightEffect = new lightingTypes[x](light.color, light.option[0], light.option[1]);
			lightEffect.position.set(light.pos.x, light.pos.y, light.pos.z);
			self.scene.add(lightEffect);
		}
	}
}

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.mesh = mesh;
exports.geometry = geometry;
exports.material = material;
exports.texture = texture;
function mesh(shapeGeometry, shapeMaterial, mesh) {
	var shapeMesh = new THREE.Mesh(shapeGeometry, shapeMaterial);
	if (mesh.rotation) shapeMesh.rotation.x = mesh.rotation.x, shapeMesh.rotation.y = mesh.rotation.y, shapeMesh.rotation.z = mesh.rotation.z;
	if (mesh.position) shapeMesh.position.x = mesh.position.x, shapeMesh.position.y = mesh.position.y, shapeMesh.position.z = mesh.position.z;
	if (mesh.scale) shapeMesh.scale.x = mesh.scale.x, shapeMesh.scale.y = mesh.scale.y, shapeMesh.scale.z = mesh.scale.z;
	if (mesh.visible) shapeMesh.visible = mesh.visible;

	if (mesh.reticle.display) {
		Reticulum.add(shapeMesh, {
			onGazeOver: function onGazeOver() {
				// do something when user targets object
				// console.log(this.material.emissive);
				if (mesh.reticle.onGazeOver) mesh.reticle.onGazeOver(shapeMaterial, self);
				// shapeMaterial.color.setHex( mesh.reticle.scrollColor );
				// shapeMaterial.color = "0xff0000" ;
				Reticulum.distance = Reticulum.distance * 10;
			},
			onGazeOut: function onGazeOut() {
				if (mesh.reticle.onGazeOut) mesh.reticle.onGazeOut(shapeMaterial, self);
				// do something when user moves reticle off targeted object
				// console.log(this.material.emissive);
				// Reticulum.distance = Reticulum.distance/2;
			},
			onGazeLong: function onGazeLong() {
				if (mesh.reticle.gazeLong) mesh.reticle.gazeLong(shapeMaterial, self);
			},
			onGazeClick: function onGazeClick() {
				if (mesh.reticle.gazeClick) mesh.reticle.gazeClick(shapeMaterial, self);
				// console.log(tween);
				// if(mesh.tween) mesh.tween.animation.start();
			}

		});
	}
	if (mesh.renderOrder) shapeMesh.renderOrder = mesh.renderOrder;

	if (mesh.functions) {

		var bespokeFunctions = Object.getOwnPropertyNames(mesh.functions).filter(function (p) {
			if (typeof mesh.functions[p] === 'function') mesh.functions[p](shapeMaterial, self);
		});
	}
	return shapeMesh;
}

function geometry(geometry) {
	// GEOMETRY
	var geometryTypes = [THREE.PlaneBufferGeometry, THREE.BoxGeometry, THREE.SphereGeometry, THREE.PlaneGeometry];
	var geometryStrings = ["PlaneBufferGeometry", "BoxGeometry", "SphereGeometry", "PlaneGeometry"];
	//for each type of material listed above
	for (var x = 0; x < geometryTypes.length; x++) {
		//check if the passed material matches one of them
		if (geometry.type == geometryStrings[x]) {
			//create a material with the associated type
			var shapeGeometry = new geometryTypes[x](geometry.size[0], geometry.size[1], geometry.size[2]);
			return shapeGeometry;
		}
	}
}

function material(material, texture) {
	if (material) {
		var materialTypes = [THREE.MeshPhongMaterial, THREE.MeshLambertMaterial, THREE.MeshBasicMaterial];
		var materialStrings = ["MeshPhongMaterial", "MeshLambertMaterial", "MeshBasicMaterial"];
		var shadingTypes = [THREE.FlatShading];
		var shadingStrings = ["FlatShading"];

		//for each type of material listed above
		for (var x = 0; x < materialTypes.length; x++) {
			//check if the passed material matches one of them
			if (material.type == materialStrings[x]) {
				//create a material with the associated type
				var shapeMaterial = new materialTypes[x]({
					color: material.color || null,
					specular: material.specular || null,
					shininess: material.shininess || null,
					opacity: material.opacity || null,
					transparent: material.transparent || null
				});

				if (material.depthTest) {
					console.log(material);
					shapeMaterial.depthTest = material.depthTest;
				}
				if (material.depthWrite) shapeMaterial.depthWrite = material.depthWrite;
				if (texture) shapeMaterial.map = this.texture(texture);
			}
		}
		if (material.shading) {
			//for each type of shading listed above
			for (var _x = 0; _x < shadingTypes.length; _x++) {
				//check if the passed material matches one of them
				if (material.shading == shadingStrings[_x]) shapeMaterial.shading = shadingTypes[_x];
			}
		}
		return shapeMaterial;
	}
}

function createVideo(videoSRC) {
	// create the video element
	var video = document.createElement('video');
	// var video = document.getElementById( "video" );
	video.setAttribute('controls', 'playsinline', 'webkit-playsinline');

	$(video).attr('controls', '');
	$(video).attr('webkit-playsinline', '');
	$(video).attr('playsinline', '');

	video.width = 640;
	video.height = 360;
	video.autoplay = true;
	video.loop = true;
	video.src = videoSRC;
	video.play();
	return video;
}

function texture(texture) {
	var video = void 0;
	if (texture) {
		var shapeTexture;
		if (texture.sphere == "photo") {
			shapeTexture = THREE.ImageUtils.loadTexture(texture.textureImage);
			console.log("loading photo sphere texture");
		} else if (texture.sphere == "video") {
			shapeTexture = new THREE.VideoTexture(createVideo(texture.textureImage));
			shapeTexture.minFilter = THREE.LinearFilter;
			shapeTexture.magFilter = THREE.LinearFilter;
			shapeTexture.format = THREE.RGBFormat;
		} else if (!texture.sphere) {
			shapeTexture = new THREE.TextureLoader().load(texture.textureImage);
		}

		if (texture.textureWrap) {
			shapeTexture.wrapS = THREE.RepeatWrapping;
			shapeTexture.wrapT = THREE.RepeatWrapping;
			shapeTexture.repeat = new THREE.Vector2(texture.textureWrap.textureRepeat[0], texture.textureWrap.textureRepeat[1]);
		}
		if (texture.textureAnisotrophy) shapeTexture.anisotropy = this.renderer.getMaxAnisotropy();
		return shapeTexture;
	}
}

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.modelMesh = modelMesh;
function modelMesh(geometry, loadedModel) {
	var modelMesh = new THREE.Mesh(geometry, modelMaterial(loadedModel.material));
	if (loadedModel.mesh.rotation) modelMesh.rotation.x = loadedModel.mesh.rotation.x, modelMesh.rotation.y = loadedModel.mesh.rotation.y, modelMesh.rotation.z = loadedModel.mesh.rotation.z;
	if (loadedModel.mesh.position) modelMesh.position.x = loadedModel.mesh.position.x, modelMesh.position.y = loadedModel.mesh.position.y, modelMesh.position.z = loadedModel.mesh.position.z;
	if (loadedModel.mesh.scale) modelMesh.scale.x = loadedModel.mesh.scale.x, modelMesh.scale.y = loadedModel.mesh.scale.y, modelMesh.scale.z = loadedModel.mesh.scale.z;

	if (loadedModel.mesh.reticle.display) {
		var oldColor = loadedModel.material.color;
		Reticulum.add(modelMesh, {
			onGazeOver: function onGazeOver() {
				// do something when user targets object
				Reticulum.distance = Reticulum.distance * 10;
			},
			onGazeOut: function onGazeOut() {
				// do something when user moves reticle off targeted object
				Reticulum.distance = Reticulum.distance / 2;
			},
			onGazeLong: function onGazeLong() {
				if (loadedModel.mesh.reticle.gazed) loadedModel.mesh.reticle.gazed(loadedModel.mesh.name);
			},
			onGazeClick: function onGazeClick() {
				if (loadedModel.mesh.reticle.gazed) loadedModel.mesh.reticle.gazed(loadedModel.mesh.name);
			}

		});
	}

	return modelMesh;
}

function modelMaterial(loadedMaterial) {
	var material = new THREE.MeshLambertMaterial({
		color: loadedMaterial.color,
		specular: loadedMaterial.specular,
		shininess: loadedMaterial.shininess
	});
	return material;
}

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addSound = addSound;
function addSound(shapeSound) {
	//Create an AudioListener and add it to the camera
	var listener = new THREE.AudioListener();
	self.camera.add(listener);

	//Create the PositionalAudio object (passing in the listener)
	var sound = new THREE.PositionalAudio(listener);

	//Load a sound and set it as the PositionalAudio object's buffer
	var audioLoader = new THREE.AudioLoader();
	audioLoader.load(shapeSound.src, function (buffer) {
		sound.setBuffer(buffer);
		sound.setRefDistance(.1);
		sound.play();
	});

	//Finally add the sound to the mesh
	return sound;
}

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.threejm = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // implement compound meshes


var _createShape = require('./assetCreation/mesh/createShape');

var _createLight2 = require('./assetCreation/light/createLight');

var _createSound = require('./assetCreation/sound/createSound');

var _setBackground2 = require('./assetCreation/background/setBackground');

var _loadModel = require('./assetCreation/model/loadModel');

var _setup = require('./3dEnvironment/scene/setup');

var _cameraControl = require('./3dEnvironment/camera/cameraControl');

var _onframe = require('./3dEnvironment/scene/onframe');

var _physics = require('./3dEnvironment/physics/physics');

var _browser = require('./3dEnvironment/browser/browser');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// import { testSetup } from './experiments/test'; 


var threejm = exports.threejm = function () {
	function threejm(settings) {
		_classCallCheck(this, threejm);

		/*** VARS ***/
		// Scene = Object that all 3d objects / cameras are declared it to be displayed 
		this.scene = null,
		// Camera = POV of the user
		this.camera = null,
		// Renderer = how 3d elements are rendered in html (webgl) 
		this.renderer = null,
		// Effect = The VR viewer (split screen)
		this.effect = null,
		// Device Rendered = Whether the scene is rendered for Desktop or VR Headset
		this.deviceRendered = null,
		// Clock = Keeps track of the time running inside of Vr experience + between frames
		this.clock = new THREE.Clock(),
		// Controls = The controller that operates the camera
		this.controls = null, this.ismobile = null;

		this.flyControls = settings.controls.flightmode; //change this to false for fps camera controller or true for flying camera

		// keyboard movment variables
		this.controlsEnabled = false, this.moveForward = false, this.moveBackward = false, this.moveLeft = false, this.moveRight = false, this.canJump = true, this.prevTime = performance.now();
		this.velocity = new THREE.Vector3();

		// Raycaster variables
		this.raycaster = null;
		this.cameraHeight = 0.5;
		this.startUp = false;

		/*** FUNCTIONS ***/
		this.geometry = _createShape.geometry;
		this.mesh = _createShape.mesh;
		this.material = _createShape.material;
		this.texture = _createShape.texture;

		// this.video = null;
		this.videoTexture = null;

		// track created objects
		this.createdObjects = [];

		// CANNON PHYSICS
		this.time = Date.now();
		this.physicsObjects = []; // store physics objects that will animate when interacted with
		this.physicsMeshes = []; // store meshes of all objects to animate with physics objects
		this.fallHeight = 0;
		this.mode = settings.mode;

		// ar stuff
		this.arToolkitSource = null;
		this.arToolkitContext = null;
		this.onRenderFcts = [];
		this.markerControls = null;
		this.arMarker = settings.AR.arMarker;
		this.lastTimeMsec = null;
		this.arPattern = settings.AR.arPattern;

		// instructions
		this.instructions = settings.UI.instructions;
		// vr mobile movement
		this.cameraMovement = settings.controls.movmement;
		this.videoBackground = settings.AR.video;
		self = this;

		this.startThreeJM(this.mode);
		// this.testSetup();
	}

	_createClass(threejm, [{
		key: 'testSetup',
		value: function (_testSetup) {
			function testSetup() {
				return _testSetup.apply(this, arguments);
			}

			testSetup.toString = function () {
				return _testSetup.toString();
			};

			return testSetup;
		}(function () {
			testSetup();
		})
		/*** STARTING THE THREE.JS SCENE IN VR MODE ***/

	}, {
		key: 'startThreeJM',
		value: function startThreeJM(mode) {
			(0, _physics.worldPhysics)(); // set up physics in the vr environment
			if (!this.flyControls) if (mode == 'vr' || mode == 'ar' || mode == 'threesixty') (0, _physics.setCamPhysics)(); // set up physics on camera controller
			(0, _setup.setup)(mode); // setup the threeJS visualiser
			if (mode == 'vr') (0, _cameraControl.VRcameracontrol)(); // set up vr camera controller
			else if (mode == 'model') (0, _cameraControl.MODELcameracontrol)(); // setup the model viewer camera controller
				else if (mode == 'threesixty') (0, _cameraControl.THREESIXTYcameracontrol)(); // setup 360 content camera controller
					else if (mode == 'ar') (0, _cameraControl.ARcameracontrol)();
			(0, _browser.resize)(); // resize the threejs scene within the browser
			this.animate(); // animate the threejs scene + physics every frame
		}

		/*** CREATE LIGHTING SET UP ***/

	}, {
		key: 'createLight',
		value: function createLight(light) {
			(0, _createLight2.createLight)(this, light);
		}

		/*** CREATE SHAPE ***/

	}, {
		key: 'createShape',
		value: function createShape(name, createdShape) {
			// GEOMETRY
			var shapeGeometry = this.geometry(createdShape.geometry);
			// MATERIAL
			var shapeMaterial = this.material(createdShape.material, createdShape.texture);
			// MESH
			var shapeMesh = this.mesh(shapeGeometry, shapeMaterial, createdShape.mesh);
			if (createdShape.physics && !self.flyControls) {
				(0, _physics.addPhysics)(createdShape);
				// add physics to global array for animation
				self.physicsMeshes.push(shapeMesh);
			}
			this.createdObjects.push({
				name: name,
				object: shapeMesh
			});
			if (createdShape.sound) shapeMesh.add((0, _createSound.addSound)(createdShape.sound));
			this.scene.add(shapeMesh);
		}

		/*** CREATE SHAPE ***/

	}, {
		key: 'createFloor',
		value: function createFloor(createdFloor) {
			// GEOMETRY
			var floorGeometry = this.geometry(createdFloor.geometry);
			// MATERIAL
			var floorMaterial = this.material(createdFloor.material, createdFloor.texture);
			// MESH
			var floorMesh = this.mesh(floorGeometry, floorMaterial, createdFloor.mesh);
			// Add Physics floor
			if (!self.flyControls) (0, _physics.addPhysicsFloor)(createdFloor);
			// Add floor mesh
			this.scene.add(floorMesh);
		}

		/*** LOAD MODEL ***/

	}, {
		key: 'loadModel',
		value: function loadModel(name, loadedModel) {
			// Load in the mesh and add it to the scene.
			var loader = new THREE.JSONLoader();
			// loader the model and create a geometry from it
			loader.load(loadedModel.geometry.src, function (geometry) {
				console.log(geometry);
				var loadedModelMesh = (0, _loadModel.modelMesh)(geometry, loadedModel);
				if (loadedModel.physics && !self.flyControls) {
					(0, _physics.addPhysics)(loadedModel);
					// add physics to global array for animation
					self.physicsMeshes.push(loadedModelMesh);
				}
				if (loadedModel.sound) loadedModelMesh.add((0, _createSound.addSound)(loadedModel.sound));
				self.createdObjects.push({
					name: name,
					object: loadedModelMesh
				});
				self.scene.add(loadedModelMesh);
			});
		}

		/*** SET BACKGROUND ***/

	}, {
		key: 'setBackground',
		value: function setBackground(background) {
			(0, _setBackground2.setBackground)(this, background);
		}

		/*** UPDATE ALL VR OBJECTS ON EVERY FRAME ***/

	}, {
		key: 'animate',
		value: function animate() {
			requestAnimationFrame(self.animate); // recall self function every frame
			// if(!self.flyControls) VRphysics(self);
			// VRphysics(self);
			(0, _onframe.update)(self.clock.getDelta(), self.mode, _browser.resize); // update size + pos of all vr elements in browser
		}
	}]);

	return threejm;
}();

},{"./3dEnvironment/browser/browser":11,"./3dEnvironment/camera/cameraControl":12,"./3dEnvironment/physics/physics":13,"./3dEnvironment/scene/onframe":14,"./3dEnvironment/scene/setup":15,"./assetCreation/background/setBackground":16,"./assetCreation/light/createLight":17,"./assetCreation/mesh/createShape":18,"./assetCreation/model/loadModel":19,"./assetCreation/sound/createSound":20}]},{},[1]);
